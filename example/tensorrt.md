# Deploy on TensorRT

We provide an example of writing the quantization parameters generated by the "adaround" algorithm into the TensorRT platform model.

For the ONNX model "model.onnx", quantification is first performed through Dipoorlet. The activation calibration method here uses "mse" and fine-tuning its weights using the "adaround" algorithm.

```
python -m torch.distributed.launch --use_env -m dipoorlet -M model.onnx -I workdir/ -N 100 -A mse -adaround -D trt
```

Dipoorlet will generate calibrated model "adaround.onnx" and quantitative configuration information "trt_clip_val.json":


```
trt_clip_val.json:
{
    "blob_range": {
        "0": 2.4663430328313014,
        "43": 2.0301631384284935,
        "44": 2.004604876945847,
        "45": 2.3547358431970458,
        "46": 3.7930725929523827,
        "47": 1.4081256442853067,
        "48": 3.1422231943456094,
        "49": 3.3541505757916714,
        "50": 2.9029659753242845,
        "51": 2.089258746225367,
        "52": 1.5408500571797488,
        "53": 2.8442123536180173,
        "54": 3.464566072806498,
        ...
        }
}
```

Subsequently, convert the calibrated model "adaround.onnx" to a TensorRT type network and write "trt_clip_val.json" to the network

```
import tensorrt.tensorrt as trt
import json

with open('trt_clip_val.json', 'r') as f:
    dipoorlet_range = json.load(f)
    
for layer in network:
    if layer.type != trt.LayerType.SHAPE and \
        layer.type != trt.LayerType.CONSTANT and \
        layer.type != trt.LayerType.CONCATENATION and \
        layer.type != trt.LayerType.GATHER:
        layer.precision = trt.DataType.INT8
    for i in range(layer.num_inputs):
        inp = layer.get_input(i)
        if inp is not None and inp.name in dipoorlet_range:
            dmax = dipoorlet_range[inp.name]
            if inp.dynamic_range is None:
                inp.set_dynamic_range(-dmax, dmax)
                print(f'set dynamic range of tensor "{inp.name}" to {dmax}.')
    for i in range(layer.num_outputs):
        output = layer.get_output(i)
        if output.name in dipoorlet_range:
            dmax = dipoorlet_range[output.name]
            if output.dynamic_range is None:
                output.set_dynamic_range(-dmax, dmax)
                print(f'set dynamic range of tensor "{output.name}" to {dmax}.')
```