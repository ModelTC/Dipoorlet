# Deploy on Magicmind

We provide an example of writing the quantization parameters generated by the "adaround" algorithm into the magicmind platform model.

For the ONNX model "model.onnx", quantification is first performed through Dipoorlet. The activation calibration method here uses "mse" and fine-tuning its weights using the "adaround" algorithm.

```
python -m torch.distributed.launch --use_env -m dipoorlet -M model.onnx -I workdir/ -N 100 -A mse -adaround -D magicmind
```

Dipoorlet will generate calibrated model "adaround.onnx" and quantitative configuration information "magicmind_quant_param.json":


```
magicmind_quant_param.json:
{
    "blob_range": {
        "0": {
            "min": -2.1179039478302,
            "max": 2.4663430328313014
        },
        "43": {
            "min": -2.0301631384284935,
            "max": 2.0301631384284935
        },
        "44": {
            "min": 0.0,
            "max": 2.004604876945847
        },
        "45": {
            "min": 0.0,
            "max": 2.3547358431970458
        },
        ...
        }
}
```

Subsequently, convert the calibrated model "adaround.onnx" to a magicmind type network and write "magicmind_quant_param.json" to the network

```
import magicmind.python.runtime as mm
import json

with open('magicmind_quant_param.json', 'r') as f:
    dipoorlet_range = json.load(f)
    
has_set_nodes = set()
assert isinstance(network, mm.Network), "invalid network"
for idx in range(network.get_input_count()):
    ipt = network.get_input(idx)
    if ipt.get_tensor_name() not in has_set_nodes:
        tblob_range = dipoorlet_range[ipt.get_tensor_name()]
        ipt_range = mm.Range(tblob_range["min"], tblob_range["max"])
        print(f"set input node dynamic range name {ipt.get_tensor_name()} to {tblob_range['min']}, {tblob_range['max']}")
    ipt.set_dynamic_range(ipt_range, False)
    has_set_nodes.add(ipt.get_tensor_name())

for layer in network.get_all_nodes_in_network():
    for i in range(layer.get_output_count()):
        output = layer.get_output(i)
        if output is None or output.get_tensor_name() in has_set_nodes:
            continue
        tblob_range = dipoorlet_range[output.get_tensor_name()]
        out_range = mm.Range(tblob_range['min'], tblob_range['max'])
        print("set output dynamic range of tensor `{0}` to [{1}, {2}]".format(
                    output.get_tensor_name(), out_range.min, out_range.max))
        output.set_dynamic_range(out_range, False)
        has_set_nodes.add(output.get_tensor_name())
```